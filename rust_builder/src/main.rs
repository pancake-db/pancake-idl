use std::fs;

use protoc_rust::{Codegen, Customize};
use std::path::Path;

struct ProtoFile {
  name: &'static str,
  feature: Option<&'static str>,
}

impl ProtoFile {
  pub fn new(name: &'static str) -> Self {
    ProtoFile {
      name,
      feature: None,
    }
  }
}

fn main() {
  let out_dir = "../rust/src";

  let protos = vec![
    ProtoFile::new("dtype"),
    ProtoFile::new("partition_dtype"),
    ProtoFile::new("schema"),
    ProtoFile::new("ddl"),
    ProtoFile::new("dml"),
    ProtoFile::new("service"),
    ProtoFile { name: "raft", feature: Some("raft")},
  ];

  let proto_files = protos.iter()
    .map(|p| format!("../protos/{}.proto", p.name))
    .collect::<Vec<String>>();
  Codegen::new()
    .customize(Customize {
      serde_derive: Some(true),
      ..Default::default()
    })
    .out_dir(&out_dir)
    .inputs(&proto_files)
    .include("../protos")
    .run()
    .expect("protoc failed");

  let mods = protos.iter()
    .map(|p| {
      let import_str = format!("pub mod {};", p.name);
      match p.feature {
        Some(f) => {
          format!("#[cfg(feature=\"{}\")]\n{}", f, import_str)
        },
        None => import_str
      }
    })
    .collect::<Vec<String>>();
  let lib_content = format!(
    "//THIS FILE IS GENERATED BY rust_builder - DO NOT MODIFY!\n\n{}\n\n{}\n",
    mods.join("\n"),
    "pub mod custom_impls;",
  );
  fs::write(Path::new(&out_dir).join("lib.rs"), lib_content).expect("unable to write lib.rs");
}