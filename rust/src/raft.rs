// This file is generated by rust-protobuf 3.0.0-alpha.2. Do not edit
// .proto file is parsed by protoc 3.17.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `raft.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_ALPHA_2;

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct InternalWriteToPartitionRequest {
    // message fields
    pub inner: ::protobuf::MessageField<super::dml::WriteToPartitionRequest>,
    pub shard_id: ::std::string::String,
    pub segment_id: ::std::string::String,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a InternalWriteToPartitionRequest {
    fn default() -> &'a InternalWriteToPartitionRequest {
        <InternalWriteToPartitionRequest as ::protobuf::Message>::default_instance()
    }
}

impl InternalWriteToPartitionRequest {
    pub fn new() -> InternalWriteToPartitionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::dml::WriteToPartitionRequest>(
            "inner",
            |m: &InternalWriteToPartitionRequest| { &m.inner },
            |m: &mut InternalWriteToPartitionRequest| { &mut m.inner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &InternalWriteToPartitionRequest| { &m.shard_id },
            |m: &mut InternalWriteToPartitionRequest| { &mut m.shard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "segment_id",
            |m: &InternalWriteToPartitionRequest| { &m.segment_id },
            |m: &mut InternalWriteToPartitionRequest| { &mut m.segment_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InternalWriteToPartitionRequest>(
            "InternalWriteToPartitionRequest",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for InternalWriteToPartitionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.inner {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.inner)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.shard_id = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.segment_id = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.inner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.shard_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.shard_id);
        }
        if !self.segment_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.segment_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.inner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.shard_id.is_empty() {
            os.write_string(2, &self.shard_id)?;
        }
        if !self.segment_id.is_empty() {
            os.write_string(3, &self.segment_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> InternalWriteToPartitionRequest {
        InternalWriteToPartitionRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static InternalWriteToPartitionRequest {
        static instance: InternalWriteToPartitionRequest = InternalWriteToPartitionRequest {
            inner: ::protobuf::MessageField::none(),
            shard_id: ::std::string::String::new(),
            segment_id: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for InternalWriteToPartitionRequest {
    fn clear(&mut self) {
        self.inner.clear();
        self.shard_id.clear();
        self.segment_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InternalWriteToPartitionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InternalWriteToPartitionRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct MutateRequest {
    // message oneof groups
    pub value: ::std::option::Option<mutate_request::Value>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a MutateRequest {
    fn default() -> &'a MutateRequest {
        <MutateRequest as ::protobuf::Message>::default_instance()
    }
}

impl MutateRequest {
    pub fn new() -> MutateRequest {
        ::std::default::Default::default()
    }

    // .protos.schema.InternalWriteToPartitionRequest write_to_partition_request = 1;

    pub fn get_write_to_partition_request(&self) -> &InternalWriteToPartitionRequest {
        match self.value {
            ::std::option::Option::Some(mutate_request::Value::write_to_partition_request(ref v)) => v,
            _ => <InternalWriteToPartitionRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_write_to_partition_request(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_write_to_partition_request(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(mutate_request::Value::write_to_partition_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write_to_partition_request(&mut self, v: InternalWriteToPartitionRequest) {
        self.value = ::std::option::Option::Some(mutate_request::Value::write_to_partition_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write_to_partition_request(&mut self) -> &mut InternalWriteToPartitionRequest {
        if let ::std::option::Option::Some(mutate_request::Value::write_to_partition_request(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(mutate_request::Value::write_to_partition_request(InternalWriteToPartitionRequest::new()));
        }
        match self.value {
            ::std::option::Option::Some(mutate_request::Value::write_to_partition_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write_to_partition_request(&mut self) -> InternalWriteToPartitionRequest {
        if self.has_write_to_partition_request() {
            match self.value.take() {
                ::std::option::Option::Some(mutate_request::Value::write_to_partition_request(v)) => v,
                _ => panic!(),
            }
        } else {
            InternalWriteToPartitionRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InternalWriteToPartitionRequest>(
            "write_to_partition_request",
            MutateRequest::has_write_to_partition_request,
            MutateRequest::get_write_to_partition_request,
            MutateRequest::mut_write_to_partition_request,
            MutateRequest::set_write_to_partition_request,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MutateRequest>(
            "MutateRequest",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for MutateRequest {
    fn is_initialized(&self) -> bool {
        if let Some(mutate_request::Value::write_to_partition_request(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(mutate_request::Value::write_to_partition_request(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &mutate_request::Value::write_to_partition_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &mutate_request::Value::write_to_partition_request(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> MutateRequest {
        MutateRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static MutateRequest {
        static instance: MutateRequest = MutateRequest {
            value: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for MutateRequest {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MutateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MutateRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MutateRequest`
pub mod mutate_request {

    #[derive(Clone,PartialEq,Debug)]
    #[derive(::serde::Serialize, ::serde::Deserialize)]
    pub enum Value {
        write_to_partition_request(super::InternalWriteToPartitionRequest),
    }

    impl ::protobuf::Oneof for Value {
    }
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct MutateResponse {
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a MutateResponse {
    fn default() -> &'a MutateResponse {
        <MutateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MutateResponse {
    pub fn new() -> MutateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MutateResponse>(
            "MutateResponse",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for MutateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> MutateResponse {
        MutateResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static MutateResponse {
        static instance: MutateResponse = MutateResponse {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for MutateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MutateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MutateResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct MembershipConfig {
    // message fields
    pub members: ::std::vec::Vec<u64>,
    pub has_members_after_consensus: bool,
    pub members_after_consensus: ::std::vec::Vec<u64>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a MembershipConfig {
    fn default() -> &'a MembershipConfig {
        <MembershipConfig as ::protobuf::Message>::default_instance()
    }
}

impl MembershipConfig {
    pub fn new() -> MembershipConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &MembershipConfig| { &m.members },
            |m: &mut MembershipConfig| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_members_after_consensus",
            |m: &MembershipConfig| { &m.has_members_after_consensus },
            |m: &mut MembershipConfig| { &mut m.has_members_after_consensus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members_after_consensus",
            |m: &MembershipConfig| { &m.members_after_consensus },
            |m: &mut MembershipConfig| { &mut m.members_after_consensus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MembershipConfig>(
            "MembershipConfig",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for MembershipConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.members)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.has_members_after_consensus = is.read_bool()?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.members_after_consensus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.members {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.has_members_after_consensus != false {
            my_size += 2;
        }
        for value in &self.members_after_consensus {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.members {
            os.write_uint64(1, *v)?;
        };
        if self.has_members_after_consensus != false {
            os.write_bool(2, self.has_members_after_consensus)?;
        }
        for v in &self.members_after_consensus {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> MembershipConfig {
        MembershipConfig::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static MembershipConfig {
        static instance: MembershipConfig = MembershipConfig {
            members: ::std::vec::Vec::new(),
            has_members_after_consensus: false,
            members_after_consensus: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for MembershipConfig {
    fn clear(&mut self) {
        self.members.clear();
        self.has_members_after_consensus = false;
        self.members_after_consensus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MembershipConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MembershipConfig {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct SnapshotPointer {
    // message fields
    pub id: ::std::string::String,
    pub membership: ::protobuf::MessageField<MembershipConfig>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotPointer {
    fn default() -> &'a SnapshotPointer {
        <SnapshotPointer as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotPointer {
    pub fn new() -> SnapshotPointer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SnapshotPointer| { &m.id },
            |m: &mut SnapshotPointer| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MembershipConfig>(
            "membership",
            |m: &SnapshotPointer| { &m.membership },
            |m: &mut SnapshotPointer| { &mut m.membership },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SnapshotPointer>(
            "SnapshotPointer",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for SnapshotPointer {
    fn is_initialized(&self) -> bool {
        for v in &self.membership {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_string()?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.membership)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.membership.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.membership.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SnapshotPointer {
        SnapshotPointer::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static SnapshotPointer {
        static instance: SnapshotPointer = SnapshotPointer {
            id: ::std::string::String::new(),
            membership: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SnapshotPointer {
    fn clear(&mut self) {
        self.id.clear();
        self.membership.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotPointer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotPointer {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct RaftEntry {
    // message fields
    pub term: u64,
    pub index: u64,
    // message oneof groups
    pub payload: ::std::option::Option<raft_entry::Payload>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RaftEntry {
    fn default() -> &'a RaftEntry {
        <RaftEntry as ::protobuf::Message>::default_instance()
    }
}

impl RaftEntry {
    pub fn new() -> RaftEntry {
        ::std::default::Default::default()
    }

    // .protos.schema.MutateRequest normal = 3;

    pub fn get_normal(&self) -> &MutateRequest {
        match self.payload {
            ::std::option::Option::Some(raft_entry::Payload::normal(ref v)) => v,
            _ => <MutateRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_normal(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_normal(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(raft_entry::Payload::normal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_normal(&mut self, v: MutateRequest) {
        self.payload = ::std::option::Option::Some(raft_entry::Payload::normal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_normal(&mut self) -> &mut MutateRequest {
        if let ::std::option::Option::Some(raft_entry::Payload::normal(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(raft_entry::Payload::normal(MutateRequest::new()));
        }
        match self.payload {
            ::std::option::Option::Some(raft_entry::Payload::normal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_normal(&mut self) -> MutateRequest {
        if self.has_normal() {
            match self.payload.take() {
                ::std::option::Option::Some(raft_entry::Payload::normal(v)) => v,
                _ => panic!(),
            }
        } else {
            MutateRequest::new()
        }
    }

    // .protos.schema.MembershipConfig config_change = 4;

    pub fn get_config_change(&self) -> &MembershipConfig {
        match self.payload {
            ::std::option::Option::Some(raft_entry::Payload::config_change(ref v)) => v,
            _ => <MembershipConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_config_change(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_config_change(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(raft_entry::Payload::config_change(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_config_change(&mut self, v: MembershipConfig) {
        self.payload = ::std::option::Option::Some(raft_entry::Payload::config_change(v))
    }

    // Mutable pointer to the field.
    pub fn mut_config_change(&mut self) -> &mut MembershipConfig {
        if let ::std::option::Option::Some(raft_entry::Payload::config_change(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(raft_entry::Payload::config_change(MembershipConfig::new()));
        }
        match self.payload {
            ::std::option::Option::Some(raft_entry::Payload::config_change(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_config_change(&mut self) -> MembershipConfig {
        if self.has_config_change() {
            match self.payload.take() {
                ::std::option::Option::Some(raft_entry::Payload::config_change(v)) => v,
                _ => panic!(),
            }
        } else {
            MembershipConfig::new()
        }
    }

    // .protos.schema.SnapshotPointer snapshot_pointer = 5;

    pub fn get_snapshot_pointer(&self) -> &SnapshotPointer {
        match self.payload {
            ::std::option::Option::Some(raft_entry::Payload::snapshot_pointer(ref v)) => v,
            _ => <SnapshotPointer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_snapshot_pointer(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_snapshot_pointer(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(raft_entry::Payload::snapshot_pointer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_snapshot_pointer(&mut self, v: SnapshotPointer) {
        self.payload = ::std::option::Option::Some(raft_entry::Payload::snapshot_pointer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_snapshot_pointer(&mut self) -> &mut SnapshotPointer {
        if let ::std::option::Option::Some(raft_entry::Payload::snapshot_pointer(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(raft_entry::Payload::snapshot_pointer(SnapshotPointer::new()));
        }
        match self.payload {
            ::std::option::Option::Some(raft_entry::Payload::snapshot_pointer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_snapshot_pointer(&mut self) -> SnapshotPointer {
        if self.has_snapshot_pointer() {
            match self.payload.take() {
                ::std::option::Option::Some(raft_entry::Payload::snapshot_pointer(v)) => v,
                _ => panic!(),
            }
        } else {
            SnapshotPointer::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "term",
            |m: &RaftEntry| { &m.term },
            |m: &mut RaftEntry| { &mut m.term },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &RaftEntry| { &m.index },
            |m: &mut RaftEntry| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MutateRequest>(
            "normal",
            RaftEntry::has_normal,
            RaftEntry::get_normal,
            RaftEntry::mut_normal,
            RaftEntry::set_normal,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MembershipConfig>(
            "config_change",
            RaftEntry::has_config_change,
            RaftEntry::get_config_change,
            RaftEntry::mut_config_change,
            RaftEntry::set_config_change,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SnapshotPointer>(
            "snapshot_pointer",
            RaftEntry::has_snapshot_pointer,
            RaftEntry::get_snapshot_pointer,
            RaftEntry::mut_snapshot_pointer,
            RaftEntry::set_snapshot_pointer,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RaftEntry>(
            "RaftEntry",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for RaftEntry {
    fn is_initialized(&self) -> bool {
        if let Some(raft_entry::Payload::normal(ref v)) = self.payload {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(raft_entry::Payload::config_change(ref v)) = self.payload {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(raft_entry::Payload::snapshot_pointer(ref v)) = self.payload {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.term = is.read_uint64()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.index = is.read_uint64()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.payload = ::std::option::Option::Some(raft_entry::Payload::normal(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.payload = ::std::option::Option::Some(raft_entry::Payload::config_change(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.payload = ::std::option::Option::Some(raft_entry::Payload::snapshot_pointer(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.term != 0 {
            my_size += ::protobuf::rt::value_size(1, self.term, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &raft_entry::Payload::normal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &raft_entry::Payload::config_change(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &raft_entry::Payload::snapshot_pointer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.term != 0 {
            os.write_uint64(1, self.term)?;
        }
        if self.index != 0 {
            os.write_uint64(2, self.index)?;
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &raft_entry::Payload::normal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &raft_entry::Payload::config_change(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &raft_entry::Payload::snapshot_pointer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RaftEntry {
        RaftEntry::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static RaftEntry {
        static instance: RaftEntry = RaftEntry {
            term: 0,
            index: 0,
            payload: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RaftEntry {
    fn clear(&mut self) {
        self.term = 0;
        self.index = 0;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RaftEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RaftEntry {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RaftEntry`
pub mod raft_entry {

    #[derive(Clone,PartialEq,Debug)]
    #[derive(::serde::Serialize, ::serde::Deserialize)]
    pub enum Payload {
        normal(super::MutateRequest),
        config_change(super::MembershipConfig),
        snapshot_pointer(super::SnapshotPointer),
    }

    impl ::protobuf::Oneof for Payload {
    }
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct RaftAppendEntriesRequest {
    // message fields
    pub term: u64,
    pub leader_id: u64,
    pub prev_log_index: u64,
    pub prev_log_term: u64,
    pub leader_commit: u64,
    pub entries: ::std::vec::Vec<RaftEntry>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RaftAppendEntriesRequest {
    fn default() -> &'a RaftAppendEntriesRequest {
        <RaftAppendEntriesRequest as ::protobuf::Message>::default_instance()
    }
}

impl RaftAppendEntriesRequest {
    pub fn new() -> RaftAppendEntriesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "term",
            |m: &RaftAppendEntriesRequest| { &m.term },
            |m: &mut RaftAppendEntriesRequest| { &mut m.term },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "leader_id",
            |m: &RaftAppendEntriesRequest| { &m.leader_id },
            |m: &mut RaftAppendEntriesRequest| { &mut m.leader_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prev_log_index",
            |m: &RaftAppendEntriesRequest| { &m.prev_log_index },
            |m: &mut RaftAppendEntriesRequest| { &mut m.prev_log_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prev_log_term",
            |m: &RaftAppendEntriesRequest| { &m.prev_log_term },
            |m: &mut RaftAppendEntriesRequest| { &mut m.prev_log_term },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "leader_commit",
            |m: &RaftAppendEntriesRequest| { &m.leader_commit },
            |m: &mut RaftAppendEntriesRequest| { &mut m.leader_commit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &RaftAppendEntriesRequest| { &m.entries },
            |m: &mut RaftAppendEntriesRequest| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RaftAppendEntriesRequest>(
            "RaftAppendEntriesRequest",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for RaftAppendEntriesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.term = is.read_uint64()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leader_id = is.read_uint64()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.prev_log_index = is.read_uint64()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.prev_log_term = is.read_uint64()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leader_commit = is.read_uint64()?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.term != 0 {
            my_size += ::protobuf::rt::value_size(1, self.term, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prev_log_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.prev_log_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prev_log_term != 0 {
            my_size += ::protobuf::rt::value_size(4, self.prev_log_term, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.leader_commit != 0 {
            my_size += ::protobuf::rt::value_size(5, self.leader_commit, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.term != 0 {
            os.write_uint64(1, self.term)?;
        }
        if self.leader_id != 0 {
            os.write_uint64(2, self.leader_id)?;
        }
        if self.prev_log_index != 0 {
            os.write_uint64(3, self.prev_log_index)?;
        }
        if self.prev_log_term != 0 {
            os.write_uint64(4, self.prev_log_term)?;
        }
        if self.leader_commit != 0 {
            os.write_uint64(5, self.leader_commit)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RaftAppendEntriesRequest {
        RaftAppendEntriesRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static RaftAppendEntriesRequest {
        static instance: RaftAppendEntriesRequest = RaftAppendEntriesRequest {
            term: 0,
            leader_id: 0,
            prev_log_index: 0,
            prev_log_term: 0,
            leader_commit: 0,
            entries: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RaftAppendEntriesRequest {
    fn clear(&mut self) {
        self.term = 0;
        self.leader_id = 0;
        self.prev_log_index = 0;
        self.prev_log_term = 0;
        self.leader_commit = 0;
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RaftAppendEntriesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RaftAppendEntriesRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct RaftConflictOp {
    // message fields
    pub term: u64,
    pub index: u64,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RaftConflictOp {
    fn default() -> &'a RaftConflictOp {
        <RaftConflictOp as ::protobuf::Message>::default_instance()
    }
}

impl RaftConflictOp {
    pub fn new() -> RaftConflictOp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "term",
            |m: &RaftConflictOp| { &m.term },
            |m: &mut RaftConflictOp| { &mut m.term },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &RaftConflictOp| { &m.index },
            |m: &mut RaftConflictOp| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RaftConflictOp>(
            "RaftConflictOp",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for RaftConflictOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.term = is.read_uint64()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.index = is.read_uint64()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.term != 0 {
            my_size += ::protobuf::rt::value_size(1, self.term, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.term != 0 {
            os.write_uint64(1, self.term)?;
        }
        if self.index != 0 {
            os.write_uint64(2, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RaftConflictOp {
        RaftConflictOp::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 7)
    }

    fn default_instance() -> &'static RaftConflictOp {
        static instance: RaftConflictOp = RaftConflictOp {
            term: 0,
            index: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RaftConflictOp {
    fn clear(&mut self) {
        self.term = 0;
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RaftConflictOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RaftConflictOp {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(::serde::Serialize, ::serde::Deserialize)]
pub struct RaftAppendEntriesResponse {
    // message fields
    pub term: u64,
    pub success: bool,
    pub conflict_op: ::protobuf::MessageField<RaftConflictOp>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RaftAppendEntriesResponse {
    fn default() -> &'a RaftAppendEntriesResponse {
        <RaftAppendEntriesResponse as ::protobuf::Message>::default_instance()
    }
}

impl RaftAppendEntriesResponse {
    pub fn new() -> RaftAppendEntriesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "term",
            |m: &RaftAppendEntriesResponse| { &m.term },
            |m: &mut RaftAppendEntriesResponse| { &mut m.term },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &RaftAppendEntriesResponse| { &m.success },
            |m: &mut RaftAppendEntriesResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RaftConflictOp>(
            "conflict_op",
            |m: &RaftAppendEntriesResponse| { &m.conflict_op },
            |m: &mut RaftAppendEntriesResponse| { &mut m.conflict_op },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RaftAppendEntriesResponse>(
            "RaftAppendEntriesResponse",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for RaftAppendEntriesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.conflict_op {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.term = is.read_uint64()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.success = is.read_bool()?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.conflict_op)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.term != 0 {
            my_size += ::protobuf::rt::value_size(1, self.term, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.success != false {
            my_size += 2;
        }
        if let Some(v) = self.conflict_op.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.term != 0 {
            os.write_uint64(1, self.term)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if let Some(v) = self.conflict_op.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RaftAppendEntriesResponse {
        RaftAppendEntriesResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 8)
    }

    fn default_instance() -> &'static RaftAppendEntriesResponse {
        static instance: RaftAppendEntriesResponse = RaftAppendEntriesResponse {
            term: 0,
            success: false,
            conflict_op: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RaftAppendEntriesResponse {
    fn clear(&mut self) {
        self.term = 0;
        self.success = false;
        self.conflict_op.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RaftAppendEntriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RaftAppendEntriesResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nraft.proto\x12\rprotos.schema\x1a\tdml.proto\"\x96\x01\n\x1fInternal\
    WriteToPartitionRequest\x129\n\x05inner\x18\x01\x20\x01(\x0b2#.protos.dm\
    l.WriteToPartitionRequestR\x05inner\x12\x19\n\x08shard_id\x18\x02\x20\
    \x01(\tR\x07shardId\x12\x1d\n\nsegment_id\x18\x03\x20\x01(\tR\tsegmentId\
    \"\x87\x01\n\rMutateRequest\x12m\n\x1awrite_to_partition_request\x18\x01\
    \x20\x01(\x0b2..protos.schema.InternalWriteToPartitionRequestH\0R\x17wri\
    teToPartitionRequestB\x07\n\x05value\"\x10\n\x0eMutateResponse\"\xa3\x01\
    \n\x10MembershipConfig\x12\x18\n\x07members\x18\x01\x20\x03(\x04R\x07mem\
    bers\x12=\n\x1bhas_members_after_consensus\x18\x02\x20\x01(\x08R\x18hasM\
    embersAfterConsensus\x126\n\x17members_after_consensus\x18\x03\x20\x03(\
    \x04R\x15membersAfterConsensus\"b\n\x0fSnapshotPointer\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12?\n\nmembership\x18\x02\x20\x01(\x0b2\x1f.\
    protos.schema.MembershipConfigR\nmembership\"\x8d\x02\n\tRaftEntry\x12\
    \x12\n\x04term\x18\x01\x20\x01(\x04R\x04term\x12\x14\n\x05index\x18\x02\
    \x20\x01(\x04R\x05index\x126\n\x06normal\x18\x03\x20\x01(\x0b2\x1c.proto\
    s.schema.MutateRequestH\0R\x06normal\x12F\n\rconfig_change\x18\x04\x20\
    \x01(\x0b2\x1f.protos.schema.MembershipConfigH\0R\x0cconfigChange\x12K\n\
    \x10snapshot_pointer\x18\x05\x20\x01(\x0b2\x1e.protos.schema.SnapshotPoi\
    nterH\0R\x0fsnapshotPointerB\t\n\x07payload\"\xee\x01\n\x18RaftAppendEnt\
    riesRequest\x12\x12\n\x04term\x18\x01\x20\x01(\x04R\x04term\x12\x1b\n\tl\
    eader_id\x18\x02\x20\x01(\x04R\x08leaderId\x12$\n\x0eprev_log_index\x18\
    \x03\x20\x01(\x04R\x0cprevLogIndex\x12\"\n\rprev_log_term\x18\x04\x20\
    \x01(\x04R\x0bprevLogTerm\x12#\n\rleader_commit\x18\x05\x20\x01(\x04R\
    \x0cleaderCommit\x122\n\x07entries\x18\x06\x20\x03(\x0b2\x18.protos.sche\
    ma.RaftEntryR\x07entries\":\n\x0eRaftConflictOp\x12\x12\n\x04term\x18\
    \x01\x20\x01(\x04R\x04term\x12\x14\n\x05index\x18\x02\x20\x01(\x04R\x05i\
    ndex\"\x89\x01\n\x19RaftAppendEntriesResponse\x12\x12\n\x04term\x18\x01\
    \x20\x01(\x04R\x04term\x12\x18\n\x07success\x18\x02\x20\x01(\x08R\x07suc\
    cess\x12>\n\x0bconflict_op\x18\x03\x20\x01(\x0b2\x1d.protos.schema.RaftC\
    onflictOpR\nconflictOpb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        deps.push(super::dml::file_descriptor());
        let mut messages = ::std::vec::Vec::new();
        messages.push(InternalWriteToPartitionRequest::generated_message_descriptor_data());
        messages.push(MutateRequest::generated_message_descriptor_data());
        messages.push(MutateResponse::generated_message_descriptor_data());
        messages.push(MembershipConfig::generated_message_descriptor_data());
        messages.push(SnapshotPointer::generated_message_descriptor_data());
        messages.push(RaftEntry::generated_message_descriptor_data());
        messages.push(RaftAppendEntriesRequest::generated_message_descriptor_data());
        messages.push(RaftConflictOp::generated_message_descriptor_data());
        messages.push(RaftAppendEntriesResponse::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
